"""
**********************************************************************

  A RapydScript to JavaScript compiler.
  https://github.com/atsepkov/RapydScript

  -------------------------------- (C) ---------------------------------

                       Author: Alexander Tsepkov
                         <atsepkov@pyjeon.com>
                         http://www.pyjeon.com

  Distributed under Apache 2.0 license:
    Copyright 2013 (c) Alexander Tsepkov <atsepkov@pyjeon.com>

  RapydScript source code is originally based on UglifyJS2 (covered
  by BSD license). UglifyJS2 was written by Mihai Bazon
  <mihai.bazon@gmail.com>, who is its respective copyright holder.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

        * Redistributions of source code must retain the above
          copyright notice, this list of conditions and the following
          disclaimer.

        * Redistributions in binary form must reproduce the above
          copyright notice, this list of conditions and the following
          disclaimer in the documentation and/or other materials
          provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.

 **********************************************************************
"""
"use strict"

def OutputStream(options):
    options = defaults(options, {
        indent_start: 0,
        indent_level: 4,
        quote_keys: False,
        space_colon: True,
        ascii_only: False,
        inline_script: False,
        width: 80,
        max_line_len: 32000,
        ie_proof: True,
        beautify: False,
        source_map: None,
        bracketize: False,
        semicolons: True,
        comments: False,
        preserve_line: False,
        omit_baselib: False,
        baselib: None,
        private_scope: True,
        auto_bind: False,
        write_name: True
    }, True)
    indentation = 0
    current_col = 0
    current_line = 1
    current_pos = 0
    OUTPUT = ""
    IMPORTED = {}
    def to_ascii(str_, identifier):
        return str_.replace(/[\u0080-\uffff]/g, def(ch):
            code = ch.charCodeAt(0).toString(16)
            if code.length <= 2 and not identifier:
                while code.length < 2:
                    code = "0" + code

                return "\\x" + code
            else:
                while code.length < 4:
                    code = "0" + code

                return "\\u" + code

        )

    def make_string(str_):
        dq = 0
        sq = 0
        str_ = str_.replace(/[\\\b\f\n\r\t\x22\x27\u2028\u2029\0]/g, def(s):
            tmp_ = s
            if tmp_ == "\\":
                return "\\\\"
            elif tmp_ == "\b":
                return "\\b"
            elif tmp_ == "\f":
                return "\\f"
            elif tmp_ == "\n":
                return "\\n"
            elif tmp_ == "	":
                return "\\t"
            elif tmp_ == "\r":
                return "\\r"
            elif tmp_ == "\u2028":
                return "\\u2028"
            elif tmp_ == "\u2029":
                return "\\u2029"
            elif tmp_ == '"':
                dq += 1
                return '"'
            elif tmp_ == "'":
                sq += 1
                return "'"
            elif tmp_ == "\0":
                return "\\0"
            return s
        )
        if options.ascii_only:
            str_ = to_ascii(str_)

        if dq > sq:
            return "'" + str_.replace(/\x27/g, "\\'") + "'"
        else:
            return '"' + str_.replace(/\x22/g, '\\"') + '"'

    def encode_string(str_):
        ret = make_string(str_)
        if options.inline_script:
            ret = ret.replace(/<\x2fscript([>\/\t\n\f\r ])/gi, "<\\/script$1")

        return ret

    def make_name(name):
        name = name.toString()
        if options.ascii_only:
            name = to_ascii(name, True)

        return name

    def make_indent(back):
        return repeat_string(" ", options.indent_start + indentation - back * options.indent_level)

    # -----[ beautification/minification ]-----
    might_need_space = False
    might_need_semicolon = False
    last = None
    def last_char():
        return last.charAt(last.length - 1)

    def maybe_newline():
        if options.max_line_len and current_col > options.max_line_len:
            print_("\n")


    requireSemicolonChars = makePredicate("( [ + * / - , .")
    def print_(str_):
        nonlocal might_need_space, might_need_semicolon, last, current_line, current_pos, current_col, OUTPUT
        str_ = JS("String(str_)")
        ch = str_.charAt(0)
        if might_need_semicolon:
            if (not ch or ";}".indexOf(ch) < 0) and not /[;]$/.test(last):
                if options.semicolons or requireSemicolonChars(ch):
                    OUTPUT += ";"
                    current_col += 1
                    current_pos += 1
                else:
                    OUTPUT += "\n"
                    current_pos += 1
                    current_line += 1
                    current_col = 0

                if not options.beautify:
                    might_need_space = False


            might_need_semicolon = False
            maybe_newline()

        if not options.beautify and options.preserve_line and stack[stack.length - 1]:
            target_line = stack[stack.length - 1].start.line
            while current_line < target_line:
                OUTPUT += "\n"
                current_pos += 1
                current_line += 1
                current_col = 0
                might_need_space = False


        if might_need_space:
            prev = last_char()
            if is_identifier_char(prev) and (is_identifier_char(ch) or ch == "\\")
            or /^[\+\-\/]$/.test(ch) and ch == prev:
                OUTPUT += " "
                current_col += 1
                current_pos += 1

            might_need_space = False

        a = str_.split(/\r?\n/)
        n = a.length - 1
        current_line += n
        if n == 0:
            current_col += a[n].length
        else:
            current_col = a[n].length

        current_pos += str_.length
        last = str_
        OUTPUT += str_

    space = options.beautify ? def(): print_(" ")
    : def():
        nonlocal might_need_space
        might_need_space = True

    indent = options.beautify ? def(half):
        if options.beautify:
            print_(make_indent((half ? 0.5 : 0)))
    : noop

    with_indent = options.beautify ? def(col, cont):
        nonlocal indentation
        if col is True:
            col = next_indent()

        save_indentation = indentation
        indentation = col
        ret = cont()
        indentation = save_indentation
        return ret
    : def(col, cont):
        return cont()

    newline = options.beautify ? def():
        print_("\n")
    : noop

    semicolon = options.beautify ? def():
        print_(";")
    : def():
        nonlocal might_need_semicolon
        might_need_semicolon = True

    def force_semicolon():
        nonlocal might_need_semicolon
        might_need_semicolon = False
        print_(";")

    def next_indent():
        return indentation + options.indent_level

    def spaced():
        for i, x in enumerate(arguments):
            if i > 0:
                space()
            print_(x)

    def end_statement():
        semicolon()
        newline()

    def with_block(cont):
        ret = None
        print_("{")
        newline()
        with_indent(next_indent(), def():
            nonlocal ret
            ret = cont()
        )
        indent()
        print_("}")
        return ret

    def with_parens(cont):
        print_("(")
        #XXX: still nice to have that for argument lists
        #var ret = with_indent(current_col, cont);
        ret = cont()
        print_(")")
        return ret

    def with_square(cont):
        print_("[")
        #var ret = with_indent(current_col, cont);
        ret = cont()
        print_("]")
        return ret

    def comma():
        print_(",")
        space()

    def colon():
        print_(":")
        if options.space_colon:
            space()


    add_mapping = (options.source_map ? def(token, name):
        try:
            if token:
                options.source_map.add(token.file or "?", current_line, current_col, token.line, token.col, (not name and token.type == "name" ? token.value : name))
        except as ex:
            AST_Node.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
                file: token.file,
                line: token.line,
                col: token.col,
                cline: current_line,
                ccol: current_col,
                name: name or ""
            })
    : noop)

    def get():
        return OUTPUT

    # generates: '[name] = '
    def assign_var(name):
        if typeof name is "string":
            print_(name)
        else:
            name.print(this)
        space()
        print_("=")
        space()

    stack = []
    return {
        get: get,
        toString: get,
        indent: indent,
        indentation: def():
            return indentation
        ,
        current_width: def():
            return current_col - indentation
        ,
        should_break: def():
            return options.width and this.current_width() >= options.width
        ,
        newline: newline,
        print: print_,
        space: space,
        comma: comma,
        colon: colon,
        last: def():
            return last
        ,
        semicolon: semicolon,
        force_semicolon: force_semicolon,
        to_ascii: to_ascii,
        print_name: def(name):
            print_(make_name(name))
        ,
        print_string: def(str_):
            print_(encode_string(str_))
        ,
        next_indent: next_indent,
        with_indent: with_indent,
        with_block: with_block,
        with_parens: with_parens,
        spaced: spaced,
        end_statement: end_statement,
        with_square: with_square,
        add_mapping: add_mapping,
        assign: assign_var,
#        prologue: prologue,
        get_baselib: def(key):
            if not options.omit_baselib:
                return options.baselib[key]
            return None
        ,
        import: def(key):
            if not IMPORTED.hasOwnProperty(key):
                IMPORTED[key] = key
                return True
            return False
        ,
        is_main: def():
            return OUTPUT.length == 0
        ,
        option: def(opt):
            return options[opt]
        ,
        line: def():
            return current_line
        ,
        col: def():
            return current_col
        ,
        pos: def():
            return current_pos
        ,
        push_node: def(node):
            stack.push(node)
        ,
        pop_node: def():
            return stack.pop()
        ,
        stack: def():
            return stack
        ,
        parent: def(n):
            return stack[stack.length - 2 - (n or 0)]

    }


# -----[ code generators ]-----
(def():
    # -----[ utils ]-----
    SPECIAL_METHODS = {
        bind: "ՐՏ_bind",
        rebind_all: "ՐՏ_rebindAll",
        bool: "!!",
        "float": "parseFloat",
        "int": "parseInt",
        mixin: "ՐՏ_mixin",
        print: "ՐՏ_print",
        eslice: "ՐՏ_eslice",
    }
    INDEX_COUNTER = 0
    def DEFPRINT(nodetype, generator):
        nodetype.DEFMETHOD("_codegen", generator)

    AST_Node.DEFMETHOD("print", def(stream, force_parens):
        self = this
        generator = self._codegen
        stream.push_node(self)
        if force_parens or self.needs_parens(stream):
            stream.with_parens(def():
                self.add_comments(stream)
                self.add_source_map(stream)
                generator(self, stream)
            )
        else:
            self.add_comments(stream)
            self.add_source_map(stream)
            generator(self, stream)

        stream.pop_node()
    )
    AST_Node.DEFMETHOD("print_to_string", def(options):
        s = OutputStream(options)
        this.print(s)
        return s.get()
    )
    # -----[ comments ]-----
    AST_Node.DEFMETHOD("add_comments", def(output):
        c = output.option("comments")
        self = this
        if c:
            start = self.start
            if start and not start._comments_dumped:
                start._comments_dumped = True
                comments = start.comments_before
                # XXX: ugly fix for https://github.com/mishoo/RapydScript2/issues/112
                #      if this node is `return` or `throw`, we cannot allow comments before
                #      the returned or thrown value.
                if isinstance(self, AST_Exit) and self.value and self.value.start.comments_before.length > 0:
                    comments = (comments or []).concat(self.value.start.comments_before)
                    self.value.start.comments_before = []

                if c.test:
                    comments = comments.filter(def(comment):
                        return c.test(comment.value)
                    )
                elif typeof c == "function":
                    comments = comments.filter(def(comment):
                        return c(self, comment)
                    )

                comments.forEach(def(c):
                    if c.type == "comment1":
                        output.print("//" + c.value + "\n")
                        output.indent()
                    elif c.type == "comment2":
                        output.print("/*" + c.value + "*/")
                        if start.nlb:
                            output.print("\n")
                            output.indent()
                        else:
                            output.space()


                )


    )
    # -----[ PARENTHESES ]-----
    def PARENS(nodetype, func):
        nodetype.DEFMETHOD("needs_parens", func)

    PARENS(AST_Node, def():
        return False
    )
    # a function expression needs parens around it when it's provably
    # the first token to appear in a statement.
    PARENS(AST_Function, def(output):
        return first_in_statement(output)
    )
    # same goes for an object literal, because otherwise it would be
    # interpreted as a block of code.
    PARENS(AST_Object, def(output):
        return first_in_statement(output)
    )
    PARENS(AST_Unary, def(output):
        p = output.parent()
        return isinstance(p, AST_PropAccess) and p.expression is this
    )
    PARENS(AST_Seq, def(output):
        p = output.parent()
        return isinstance(p, AST_Unary) or isinstance(p, AST_VarDef) or isinstance(p, AST_Dot) or isinstance(p, AST_ObjectProperty) or isinstance(p, AST_Conditional)
    )
    PARENS(AST_Binary, def(output):
        p = output.parent()
        # (foo && bar)()
        if isinstance(p, AST_BaseCall) and p.expression is this:
            return True

        # typeof (foo && bar)
        if isinstance(p, AST_Unary):
            return True

        # (foo && bar)["prop"], (foo && bar).prop
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True

        # this deals with precedence: 3 * (2 + 1)
        if isinstance(p, AST_Binary):
            po = p.operator
            pp = PRECEDENCE[po]
            so = this.operator
            sp = PRECEDENCE[so]
            if pp > sp or pp == sp and this is p.right and not (so == po and (so == "*" or so == "&&" or so == "||")):
                return True
    )
    PARENS(AST_PropAccess, def(output):
        p = output.parent()
        if isinstance(p, AST_New) and p.expression is this:
            # i.e. new (foo.bar().baz)
            #
            # if there's one call into this subtree, then we need
            # parens around it too, otherwise the call will be
            # interpreted as passing the arguments to the upper New
            # expression.
            try:
                this.walk(new TreeWalker(def(node):
                    if isinstance(node, AST_BaseCall):
                        raise p
                ))
            except as ex:
                if ex is not p:
                    raise ex
                return True
    )
    PARENS(AST_BaseCall, def(output):
        p = output.parent()
        return isinstance(p, AST_New) and p.expression is this
    )
    PARENS(AST_New, def(output):
        p = output.parent()
        if no_constructor_parens(this, output) and (isinstance(p, AST_PropAccess) \
                or isinstance(p, AST_BaseCall) and p.expression is this):
            # (new foo)(bar)
            return True
    )
    PARENS(AST_Number, def(output):
        p = output.parent()
        if this.getValue() < 0 and isinstance(p, AST_PropAccess) and p.expression is this:
            return True
    )
    PARENS(AST_NaN, def(output):
        p = output.parent()
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True
    )
    def assign_and_conditional_paren_rules(output):
        p = output.parent()
        # !(a = false) → true
        if isinstance(p, AST_Unary):
            return True

        # 1 + (a = 2) + 3 → 6, side effect setting a = 2
        if isinstance(p, AST_Binary) and not (isinstance(p, AST_Assign)):
            return True

        # (a = func)() —or— new (a = Object)()
        if isinstance(p, AST_BaseCall) and p.expression is this:
            return True

        # (a = foo) ? bar : baz
        if isinstance(p, AST_Conditional) and p.condition is this:
            return True

        # (a = foo)["prop"] —or— (a = foo).prop
        if isinstance(p, AST_PropAccess) and p.expression is this:
            return True

    PARENS(AST_Assign, assign_and_conditional_paren_rules)
    PARENS(AST_Conditional, assign_and_conditional_paren_rules)
    # -----[ PRINTERS ]-----
    DEFPRINT(AST_Directive, def(self, output):
        output.print_string(self.value)
        output.semicolon()
    )
    DEFPRINT(AST_Debugger, def(self, output):
        output.print("debugger")
        output.semicolon()
    )
    # -----[ statements ]-----
    def display_body(body, is_toplevel, output):
        last = body.length - 1
        body.forEach(def(stmt, i):
            if not (isinstance(stmt, AST_EmptyStatement)) and not (isinstance(stmt, AST_Definitions)):
                output.indent()
                stmt.print(output)
                if not (i == last and is_toplevel):
                    output.newline()
        )

    def bind_methods(methods, output):
        # bind the methods
        for arg in dir(methods):
            output.indent()
            output.print("this.")
            output.assign(arg)
            output.print("ՐՏ_bind")
            output.with_parens(def():
                output.print("this.")
                output.print(arg)
                output.comma()
                output.print("this")
            )
            output.semicolon()
            output.newline()

    def write_imports(module_, output):
        imports = []
        for import_id in Object.keys(module_.imports):
            imports.push(module_.imports[import_id])
        imports.sort(def(a, b):
            a, b = a.import_order, b.import_order
            return ((a < b) ? -1 : ((a > b) ? 1 : 0))
        )
        if imports.length > 1:
            output.indent()
            output.print('var ՐՏ_modules = {};')
            output.newline()

        # Declare all variable names exported from the modules as global symbols
        nonlocalvars = {}
        for module_ in imports:
            for name in module_.nonlocalvars:
                nonlocalvars[name] = True
        nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(', ')
        if nonlocalvars.length:
            output.indent()
            output.print('var ' + nonlocalvars);
            output.semicolon()
            output.newline()

        # Create the module objects
        for module_ in imports:
            if module_.module_id != '__main__':
                output.indent()
                output.print('ՐՏ_modules["')
                output.print(module_.module_id)
                output.print('"] = {}')
                output.semicolon()
                output.newline()

        # Output module code
        for module_ in imports:
            if module_.module_id != '__main__':
                print_module(module_, output)

    def write_main_name(output):
        if output.option('write_name'):
            output.newline()
            output.indent()
            output.print('var __name__ = "__main__"')
            output.semicolon()
            output.newline()
            output.newline()

    def display_complex_body(node, is_toplevel, output):
        offset = 0 # argument offset, applies if this is a method of a class
        # if this is a method, add 'var self = this'
        if isinstance(node, AST_Method) and not node.static:
            output.indent()
            output.print("var")
            output.space()
            output.assign(node.argnames[0])
            output.print("this")
            output.semicolon()
            output.newline()
            offset += 1

        if isinstance(node, AST_Scope):
            # if function takes any arguments
            if node.argnames:
                # If *args is set, pass remainder of arguments to it
                if node.argnames.starargs:
                    output.indent()
                    output.print("var")
                    output.space()
                    output.assign(node.argnames.starargs)
                    output.print("[].slice.call")
                    output.with_parens(def():
                        output.print("arguments")
                        output.comma()
                        output.print(node.argnames.length - offset)
                    )
                    output.semicolon()
                    output.newline()

                # initialize default function arguments, if any
                for arg in dir(node.argnames.defaults):
                    output.indent()
                    output.print("if")
                    output.space()
                    output.with_parens(def():
                        output.print("typeof " + arg)
                        output.space()
                        output.print("===")
                        output.space()
                        output.print('"undefined"')
                    )
                    output.space()
                    output.assign(arg)
                    force_statement(node.argnames.defaults[arg], output)
                    output.semicolon()
                    output.newline()

            # rebind parent's methods and bind own methods
            # for now we'll make a naive assumption that a function
            # named __init__ will only occur inside a class
            if output.option("auto_bind") and node.name and node.name.name == "__init__":
                output.indent()
                output.print("ՐՏ_rebindAll")
                output.with_parens(def():
                    output.print("this")
                    output.comma()
                    output.print("true")
                )
                output.semicolon()
                output.newline()
                bind_methods(node.bound, output)

            declare_vars(node.localvars, output)

        elif isinstance(node, AST_Except):
            if node.argname:
                output.indent()
                output.print("var")
                output.space()
                output.assign(node.argname)
                output.print("ՐՏ_Exception")
                output.semicolon()
                output.newline()

        display_body(node.body, is_toplevel, output)

    def declare_vars(vars, output):
        # declare all variables as local, unless explictly set otherwise
        if vars.length:
            output.indent()
            output.print("var")
            output.space()
            vars.forEach(def(arg, i):
                if i:
                    output.comma()

                arg.print(output)
            )
            output.semicolon()
            output.newline()

    def declare_exports(module_id, exports, submodules, output):
        seen = {}
        for symbol in exports:
            output.newline()
            output.indent()
            output.print('ՐՏ_modules["' + module_id + '"]["' + symbol.name + '"] = ' + symbol.name)
            seen[symbol.name] = True
            output.semicolon()
            output.newline()
        for sub_module_id in submodules:
            if not seen.hasOwnProperty(module_id):
                key = sub_module_id.split('.')[-1]
                output.newline()
                output.indent()
                output.print('ՐՏ_modules["' + module_id + '"]["' + key + '"] = ')
                output.print('ՐՏ_modules["' + sub_module_id + '"]')
                output.semicolon()
                output.newline()

    def unpack_tuple(tuple, output, in_statement):
        tuple.elements.forEach(def(elem, i):
            output.indent()
            output.assign(elem)
            output.print("ՐՏ_Unpack")
            output.with_square(def():
                output.print(i)
            )
            if not in_statement or i < tuple.elements.length - 1:
                output.semicolon()
                output.newline()
        )

    AST_StatementWithBody.DEFMETHOD("_do_print_body", def(output):
        force_statement(this.body, output)
    )
    DEFPRINT(AST_Statement, def(self, output):
        self.body.print(output)
        output.semicolon()
    )
    DEFPRINT(AST_Toplevel, def(self, output):
        is_main = output.is_main()

        if output.option("private_scope") and is_main:
            output.with_parens(def():
                output.print("function()")
                output.with_block(def():
                    # strict mode is more verbose about errors, and less forgiving about them
                    # kind of like Python
                    output.indent()
                    output.print('"use strict"')
                    output.semicolon()
                    output.newline()

                    # TODO: this is a hack for now, should probably declare this in local-most scope
                    output.indent()
                    output.print("var ՐՏ_Temp")
                    output.semicolon()
                    output.newline()

#                    output.prologue(self)
                    Object.keys(self.baselib).forEach(def(key):
                        splat = output.get_baselib(key)
                        if splat: splat.print(output)
                    )
                    write_imports(self, output)
                    output.newline()
                    output.indent()
                    output.with_parens(def():
                        output.print("function()")
                        output.with_block(def():
                            write_main_name(output)
                            output.newline()
                            display_complex_body(self, True, output)
                            output.newline()
                        )
                    )
                    output.print("();")
                    output.newline()
                )
            )
            output.print("();")
            output.print("")
        else:
            if is_main:
                Object.keys(self.baselib).forEach(def(key):
                    splat = output.get_baselib(key)
                    if splat: splat.print(output)
                )
#                output.prologue(self)
                write_imports(self, output)
                write_main_name(output)

            if self.strict:
                declare_vars(self.localvars, output)

            display_body(self.body, True, output)

    )
    def print_module(self, output):
        output.newline()
        output.indent()
        output.with_parens(def():
            output.print("function()")
            output.with_block(def():
                # dump the logic of this module
                output.indent()
                output.print('var ')
                output.assign('__name__')
                output.print('"' + self.module_id + '"')
                output.semicolon()
                output.newline()
                declare_vars(self.localvars, output)
                display_body(self.body, True, output)
                declare_exports(self.module_id, self.exports, self.submodules, output)
            )
        )
        output.print("()")
        output.semicolon()
        output.newline()

    DEFPRINT(AST_Splat, def(self, output):
        if output.import(self.module.name):
            display_body(self.body.body, True, output)
            output.newline()
    )

    DEFPRINT(AST_Imports, def(container, output):

        def add_aname(aname, key, from_import):
            output.print('var ')
            output.assign(aname)
            output.print('ՐՏ_modules["')
            output.print(key)
            output.print('"]')
            if from_import:
                output.print('.')
                output.print(from_import)
            output.semicolon()
            output.newline()
            output.indent()

        for self in container.imports:
            output.import(self.module.name)
            if self.argnames:
                # A from import
                for argname in self.argnames:
                    alias = (argname.alias) ? argname.alias.name : argname.name
                    add_aname(alias, self.key, argname.name)
            else:
                if self.alias:
                    add_aname(self.alias.name, self.key, False)
                else:
                    bound_name = self.key.split('.', 1)[0]
                    add_aname(bound_name, bound_name, False)

    )
    DEFPRINT(AST_LabeledStatement, def(self, output):
        self.label.print(output)
        output.colon()
        self.body.print(output)
    )
    DEFPRINT(AST_SimpleStatement, def(self, output):
        if not (isinstance(self.body, AST_EmptyStatement)):
            self.body.print(output)
            output.semicolon()
    )
    def print_bracketed(node, output, complex):
        if node.body.length > 0:
            output.with_block(def():
                if complex:
                    display_complex_body(node, False, output)
                else:
                    display_body(node.body, False, output)
            )
        else:
            output.print("{}")

    DEFPRINT(AST_BlockStatement, def(self, output):
        print_bracketed(self, output)
    )

    DEFPRINT(AST_EmptyStatement, def(self, output):
        pass
    )

    DEFPRINT(AST_Do, def(self, output):
        output.print("do")
        output.space()
        self._do_print_body(output)
        output.space()
        output.print("while")
        output.space()
        output.with_parens(def():
            self.condition.print(output)
        )
        output.semicolon()
    )

    DEFPRINT(AST_While, def(self, output):
        output.print("while")
        output.space()
        output.with_parens(def():
            self.condition.print(output)
        )
        output.space()
        self._do_print_body(output)
    )

    def is_simple_for_in(self):
        # return true if this loop can be simplified into a basic for (i in j) loop
        if isinstance(self.object, AST_BaseCall)
        and isinstance(self.object.expression, AST_SymbolRef)
        and self.object.expression.name == "dir" and self.object.args.length == 1:
            return True
        return False

    def is_simple_for(self):
        # returns true if this loop can be simplified into a basic for(i=n;i<h;i++) loop
        if isinstance(self.object, AST_BaseCall)
        and isinstance(self.object.expression, AST_SymbolRef)
        and self.object.expression.name == "range"
        and not (isinstance(self.init, AST_Array))
        and (
            self.object.args.length < 3 or (
                isinstance(self.object.args.slice(-1)[0], AST_Number)
                or isinstance(self.object.args.slice(-1)[0], AST_Unary)
                    and self.object.args.slice(-1)[0].operator == "-"
                    and isinstance(self.object.args.slice(-1)[0].expression, AST_Number)
            )
        ):
            return True
        return False

    AST_ForIn.DEFMETHOD("_do_print_body", def(output):
        self = this
        output.with_block(def():
            nonlocal INDEX_COUNTER
            if not (is_simple_for(self) or is_simple_for_in(self)):
                # if we're using multiple iterators, unpack them
                output.indent()
                if isinstance(self.init, AST_Array):
                    output.assign("ՐՏ_Unpack")
                    output.print("ՐՏ_Iter" + INDEX_COUNTER + "[ՐՏ_Index" + INDEX_COUNTER + "];")
                    output.newline()
                    unpack_tuple(self.init, output)
                else:
                    output.assign(self.init)
                    output.print("ՐՏ_Iter" + INDEX_COUNTER + "[ՐՏ_Index" + INDEX_COUNTER + "];")
                    output.newline()

                INDEX_COUNTER += 1

            self.body.body.forEach(def(stmt, i):
                output.indent()
                stmt.print(output)
                output.newline()
            )
        )
    )

    DEFPRINT(AST_ForIn, def(self, output):
        if is_simple_for(self):
            # optimize range() into a simple for loop
            increment = None
            args = self.object.args
            tmp_ = args.length
            if tmp_ == 1:
                start = 0
                end = args[0]
            elif tmp_ == 2:
                start = args[0]
                end = args[1]
            elif tmp_ == 3:
                start = args[0]
                end = args[1]
                increment = args[2]

            output.print("for")
            output.space()
            output.with_parens(def():
                output.assign(self.init)
                start.print ? start.print(output) : output.print(start)
                output.semicolon()
                output.space()
                self.init.print(output)
                output.space()
                isinstance(increment, AST_Unary) ? output.print(">") : output.print("<")
                output.space()
                end.print(output)
                output.semicolon()
                output.space()
                self.init.print(output)
                if increment and (not (isinstance(increment, AST_Unary)) or increment.expression.value != "1"):
                    if isinstance(increment, AST_Unary):
                        output.print("-=")
                        increment.expression.print(output)
                    else:
                        output.print("+=")
                        increment.print(output)
                else:
                    if isinstance(increment, AST_Unary):
                        output.print("--")
                    else:
                        output.print("++")
            )
        elif is_simple_for_in(self):
            # optimize dir() into a simple for in loop
            output.print("for")
            output.space()
            output.with_parens(def():
                self.init.print(output)
                output.space()
                output.print('in')
                output.space()
                self.object.args[0].print(output)
            )
        else:
            # regular loop
            output.assign("var ՐՏ_Iter" + INDEX_COUNTER)
            output.print("ՐՏ_Iterable")
            output.with_parens(def():
                self.object.print(output)
            )
            output.semicolon()
            output.newline()
            output.indent()
            output.print("for")
            output.space()
            output.with_parens(def():
                output.print("var")
                output.space()
                output.assign("ՐՏ_Index" + INDEX_COUNTER)
                output.print("0")
                output.semicolon()
                output.space()
                output.print("ՐՏ_Index" + INDEX_COUNTER)
                output.space()
                output.print("<")
                output.space()
                output.print("ՐՏ_Iter" + INDEX_COUNTER + ".length")
                output.semicolon()
                output.space()
                output.print("ՐՏ_Index" + INDEX_COUNTER + "++")
            )

        output.space()
        self._do_print_body(output)
    )

    AST_ForJS.DEFMETHOD("_do_print_body", def(output):
        self = this
        output.with_block(def():
            self.body.body.forEach(def(stmt, i):
                output.indent()
                stmt.print(output)
                output.newline()
            )
        )
    )

    DEFPRINT(AST_ForJS, def(self, output):
        output.print("for")
        output.space()
        output.with_parens(def():
            self.condition.print(output)
        )
        output.space()
        self._do_print_body(output)
    )
    DEFPRINT(AST_ListComprehension, def(self, output):
        # this logic is shares by list and dict comprehensions, since the difference in output
        # isn't big
        constructor = {
            'ListComprehension': '[]',
            'DictComprehension': '{}'
        }[self.TYPE]

        if isinstance(self, AST_DictComprehension):
            add_entry = def():
                output.indent()
                output.print("ՐՏ_Result")
                output.with_square(def():
                    self.statement.print(output)
                )
                output.space()
                output.print('=')
                output.space()
                self.value_statement.print(output)
                output.semicolon()
                output.newline()
        else:
            #list comprehension
            add_entry = def():
                output.indent()
                output.print("ՐՏ_Result.push")
                output.with_parens(def():
                    self.statement.print(output)
                )
                output.semicolon()
                output.newline()

        output.with_parens(def():
            output.print("function")
            output.print("()")
            output.space()
            output.with_block(def():
                output.indent()
                output.assign("var ՐՏ_Iter")
                output.print("ՐՏ_Iterable")
                output.with_parens(def():
                    self.object.print(output)
                )
                output.comma()
                output.assign("ՐՏ_Result")
                output.print(constructor)
                # make sure to locally scope loop variables
                if isinstance(self.init, AST_Array):
                    self.init.elements.forEach(def(i):
                        output.comma()
                        i.print(output)
                    )
                else:
                    output.comma()
                    self.init.print(output)

                output.semicolon()
                output.newline()
                output.indent()
                output.print("for")
                output.space()
                output.with_parens(def():
                    output.print("var")
                    output.space()
                    output.assign("ՐՏ_Index")
                    output.print("0")
                    output.semicolon()
                    output.space()
                    output.print("ՐՏ_Index")
                    output.space()
                    output.print("<")
                    output.space()
                    output.print("ՐՏ_Iter.length")
                    output.semicolon()
                    output.space()
                    output.print("ՐՏ_Index++")
                )
                output.space()
                output.with_block(def():
                    output.indent()
                    if isinstance(self.init, AST_Array):
                        output.assign("ՐՏ_Unpack")
                        output.print("ՐՏ_Iter[ՐՏ_Index];")
                        output.newline()
                        unpack_tuple(self.init, output)
                    else:
                        output.assign(self.init)
                        output.print("ՐՏ_Iter[ՐՏ_Index];")
                        output.newline()

                    if self.condition:
                        output.indent()
                        output.print("if")
                        output.space()
                        output.with_parens(def():
                            self.condition.print(output)
                        )
                        output.space()
                        output.with_block(def():
                            add_entry()
                        )
                        output.newline()
                    else:
                        add_entry()
                )
                output.newline()
                output.indent()
                output.print("return ՐՏ_Result")
                output.semicolon()
                output.newline()
            )
        )
        output.print("()")
    )
    DEFPRINT(AST_With, def(self, output):
        output.print("with")
        output.space()
        output.with_parens(def():
            self.expression.print(output)
        )
        output.space()
        self._do_print_body(output)
    )


    # -----[ functions ]-----
    def decorate(node, output, internalsub):
        wrap = def(d):
            if d.length:
                output.print(d.slice(0)[0].name)
                output.with_parens(def():
                    wrap(d.slice(1))
                )
            else:
                internalsub()
        wrap(node.decorators)


    AST_Lambda.DEFMETHOD("_do_print", def(output, nokeyword):
        self = this
        def internalsub():
            if not nokeyword:
                output.print("function")

            if self.name:
                output.space()
                self.name.print(output)

            output.with_parens(def():
                self.argnames.forEach(def(arg, i):
                    if i:
                        output.comma()

                    arg.print(output)
                )

                # handle kwargs hook, if there is a kwargs decorator
                if self.kwargs:
                    if argnames.length:
                        output.comma()
                    # it's a generic argument name, we'll rename it in function body
                    output.print('ՐՏ_kw')
            )
            output.space()
            print_bracketed(self, output, True)

        if self.decorators and self.decorators.length:
            output.print("var")
            output.space()
            output.assign(self.name.name)
            decorate(self, output, internalsub)
            output.semicolon()
        else:
            internalsub()
    )
    DEFPRINT(AST_Lambda, def(self, output):
        self._do_print(output)
    )


    # -----[ classes ]-----
    AST_Class.DEFMETHOD("_do_print", def(output):
        self = this
        if self.external:
            return

        class_def = def(method):
            output.indent()
            self.name.print(output)
            if method and self.static.indexOf(method) != -1:
                output.assign("." + method)
            else:
                output.assign(".prototype" + ((method ? "." + method : "")))

        define_method = def(stmt):
            name = stmt.name.name
            class_def(name)
            def internalsub():
                output.print("function")
                output.space()
                output.print(name)

                output.with_parens(def():
                    stmt.argnames.forEach(def(arg, i):
                        # only strip first argument if the method isn't static
                        if self.static.indexOf(name) != -1:
                            i += 1
                        if i > 1:
                            output.comma()
                        if i:
                            arg.print(output)
                    )

                    # handle kwargs hook, if there is a kwargs decorator
                    if self.kwargs:
                        if argnames.length:
                            output.comma()
                        # it's a generic argument name, we'll rename it in function body
                        output.print('ՐՏ_kw')
                )
                print_bracketed(stmt, output, True)

            # decorate the method
            if stmt.decorators and stmt.decorators.length:
                decorate(stmt, output, internalsub)
            else:
                internalsub()
            output.semicolon()
            output.newline()

        # generate constructor
        def internalsub():
            if self.init or self.parent:
                output.print("function")
                output.space()
                self.name.print(output)
                output.print("()")
                output.space()
                output.with_block(def():
                    bind_methods(self.bound, output)
                    output.indent()
                    cname = (self.name) ? self.name : self.parent
                    cname.print(output)
                    output.print(".prototype.__init__.apply")
                    output.with_parens(def():
                        output.print("this")
                        output.comma()
                        output.print("arguments")
                    )
                    output.semicolon()
                    output.newline()
                )
            else:
                # no init method or parent, create empty init
                output.print("function")
                output.space()
                self.name.print(output)
                output.print("()")
                output.space()
                output.with_block(def():
                    bind_methods(self.bound, output)
                )

        # decorate the class
        if self.decorators and self.decorators.length:
            output.print('var ')
            output.assign(self.name)
            decorate(self, output, internalsub)
            output.semicolon()
        else:
            internalsub()
        output.newline()

        # inheritance
        if self.parent:
            output.indent()
            output.print("ՐՏ_extends")
            output.with_parens(def():
                self.name.print(output)
                output.comma()
                self.parent.print(output)
            )
            output.semicolon()
            output.newline()

        # class variables and statements
        self.statements.forEach(def(stmt):
            output.indent()
            stmt.print(output)
            output.newline()
        )

        # actual methods
        self.body.forEach(def(stmt, i):
            if isinstance(stmt, AST_Method):
                define_method(stmt)

            elif isinstance(stmt, AST_Class):
                console.error('Nested classes aren\'t supported yet')
        )
    )
    DEFPRINT(AST_Class, def(self, output):
        self._do_print(output)
    )

    DEFPRINT(AST_SymbolClassRef, def(self, output):
        self.class.print(output)
        output.print('.prototype.')
        output.print(self.name)
    )

    # -----[ exits ]-----
    AST_Exit.DEFMETHOD("_do_print", def(output, kind):
        self = this
        output.print(kind)
        if self.value:
            output.space()
            self.value.print(output)

        output.semicolon()
    )
    DEFPRINT(AST_Return, def(self, output):
        self._do_print(output, "return")
    )
    DEFPRINT(AST_Throw, def(self, output):
        self._do_print(output, "throw")
    )

    # -----[ loop control ]-----
    AST_LoopControl.DEFMETHOD("_do_print", def(output, kind):
        output.print(kind)
        if this.label:
            output.space()
            this.label.print(output)

        output.semicolon()
    )
    DEFPRINT(AST_Break, def(self, output):
        self._do_print(output, "break")
    )
    DEFPRINT(AST_Continue, def(self, output):
        self._do_print(output, "continue")
    )

    # -----[ if ]-----
    def make_then(self, output):
        if output.option("bracketize"):
            make_block(self.body, output)
            return

        # The squeezer replaces "block"-s that contain only a single
        # statement with the statement itself; technically, the AST
        # is correct, but this can create problems when we output an
        # IF having an ELSE clause where the THEN clause ends in an
        # IF *without* an ELSE block (then the outer ELSE would refer
        # to the inner IF).  This function checks for this case and
        # adds the block brackets if needed.
        if not self.body:
            return output.force_semicolon()

        if isinstance(self.body, AST_Do) and output.option("ie_proof"):
            # https://github.com/mishoo/RapydScript/issues/#issue/57 IE
            # croaks with "syntax error" on code like this: if (foo)
            # do ... while(cond); else ...  we need block brackets
            # around do/while
            make_block(self.body, output)
            return

        b = self.body
        while True:
            if isinstance(b, AST_If):
                if not b.alternative:
                    make_block(self.body, output)
                    return

                b = b.alternative
            elif isinstance(b, AST_StatementWithBody):
                b = b.body
            else:
                break

        force_statement(self.body, output)

    DEFPRINT(AST_If, def(self, output):
        output.print("if")
        output.space()
        output.with_parens(def():
            self.condition.print(output)
        )
        output.space()
        if self.alternative:
            make_then(self, output)
            output.space()
            output.print("else")
            output.space()
            force_statement(self.alternative, output)
        else:
            self._do_print_body(output)

    )

    # -----[ switch ]-----
    DEFPRINT(AST_Switch, def(self, output):
        output.print("switch")
        output.space()
        output.with_parens(def():
            self.expression.print(output)
        )
        output.space()
        if self.body.length > 0:
            output.with_block(def():
                self.body.forEach(def(stmt, i):
                    if i:
                        output.newline()

                    output.indent(True)
                    stmt.print(output)
                )
            )
        else:
            output.print("{}")
    )
    AST_SwitchBranch.DEFMETHOD("_do_print_body", def(output):
        if this.body.length > 0:
            output.newline()
            this.body.forEach(def(stmt):
                output.indent()
                stmt.print(output)
                output.newline()
            )
    )
    DEFPRINT(AST_Default, def(self, output):
        output.print("default:")
        self._do_print_body(output)
    )
    DEFPRINT(AST_Case, def(self, output):
        output.print("case")
        output.space()
        self.expression.print(output)
        output.print(":")
        self._do_print_body(output)
    )

    # -----[ exceptions ]-----
    DEFPRINT(AST_Try, def(self, output):
        output.print("try")
        output.space()
        print_bracketed(self, output)
        if self.bcatch:
            output.space()
            self.bcatch.print(output)

        if self.bfinally:
            output.space()
            self.bfinally.print(output)
    )
    DEFPRINT(AST_Catch, def(self, output):
        output.print("catch")
        output.space()
        output.with_parens(def():
            output.print("ՐՏ_Exception")
        )
        output.space()
        #        print_bracketed(self, output);
        if self.body.length > 1 or self.body[0].errors.length:
            output.with_block(def():
                output.indent()
                no_default = True
                self.body.forEach(def(exception, i):
                    if i:
                        output.print("else ")

                    if exception.errors.length:
                        output.print("if")
                        output.space()
                        output.with_parens(def():
                            exception.errors.forEach(def(err, i):
                                if i:
                                    output.newline()
                                    output.indent()
                                    output.print("||")
                                    output.space()

                                output.print("ՐՏ_Exception")
                                output.space()
                                output.print("instanceof")
                                output.space()
                                err.print(output)
                            )
                        )
                        output.space()
                    else:
                        no_default = False
                    print_bracketed(exception, output, True)
                    output.space()
                )
                if no_default:
                    output.print("else")
                    output.space()
                    output.with_block(def():
                        output.indent()
                        output.print("throw")
                        output.space()
                        output.print("ՐՏ_Exception")
                        output.semicolon()
                        output.newline()
                    )
                output.newline()
            )
        else:
            print_bracketed(self.body[0], output, True)
    )
    DEFPRINT(AST_Finally, def(self, output):
        output.print("finally")
        output.space()
        print_bracketed(self, output)
    )

    # -----[ var/const ]-----
    AST_Definitions.DEFMETHOD("_do_print", def(output, kind):
        output.print(kind)
        output.space()
        this.definitions.forEach(def(def_, i):
            if i:
                output.comma()
            def_.print(output)
        )
        p = output.parent()
        in_for = isinstance(p, AST_ForIn)
        avoid_semicolon = in_for and p.init is this
        if not avoid_semicolon:
            output.semicolon()
    )
    DEFPRINT(AST_Var, def(self, output):
        self._do_print(output, "var")
    )
    DEFPRINT(AST_Const, def(self, output):
        self._do_print(output, "const")
    )
    def parenthesize_for_noin(node, output, noin):
        if not noin:
            node.print(output)
        else:
            try:
                # need to take some precautions here:
                #    https://github.com/mishoo/RapydScript2/issues/60
                node.walk(new TreeWalker(def(node):
                    if isinstance(node, AST_Binary) and node.operator == "in":
                        raise output
                ))
                node.print(output)
            except as ex:
                if ex is not output:
                    raise ex
                node.print(output, True)

    DEFPRINT(AST_VarDef, def(self, output):
        self.name.print(output)
        if self.value:
            output.assign("")
            #            output.space();
            #            output.print("=");
            #            output.space();
            p = output.parent(1)
            noin = isinstance(p, AST_ForIn)
            parenthesize_for_noin(self.value, output, noin)
    )

    # -----[ other expressions ]-----
    CREATION = [] # FIXME: a hack, tracks variables that class is being assigned to for handling
                  # kwargs on constructor gracefully, a better approach is to split this function
                  # into AST_Call (normal functions), AST_ClassCall (class functions), and
                  # AST_New (constructors), remove DEFPRINT for AST_BaseCall altogether, add
                  # 'obj' property to AST_New and have it track the object it's assigned to. Then
                  # use that property instead of this global stack. This would also have the benefit
                  # of minimizing clutter that this function is currently dealing with.
    DEFPRINT(AST_BaseCall, def(self, output):

        # logic for defining the format of a function call (class, static, normal, decorated)
        call_format = def():
            if isinstance(self, AST_ClassCall):
                # class methods are called through the prototype unless static
                if self.static:
                    self.class.print(output)
                    output.print(".")
                    output.print(self.method)
                else:
                    self.class.print(output)
                    output.print(".prototype.")
                    output.print(self.method)
                    output.print(".call")
            else:
                # regular function call
                rename = SPECIAL_METHODS.hasOwnProperty(self.expression.name) ? SPECIAL_METHODS[self.expression.name] : undefined
                if rename:
                    # this is a special baselib function
                    output.print(rename)
                else:
                    self.expression.print(output)

        if isinstance(self, AST_New):
            # FIXME: a hack to avoid building a new type of AST object for the
            # special case of kwargs-based constructor
            object = CREATION.pop()

            if no_constructor_parens(self, output):
                call_format()
                return

        # determine if we'll be using kwargs, since there are two possible triggers for them
        has_kwarg_items = self.args.kwarg_items and self.args.kwarg_items.length
        has_kwarg_formals = self.args.kwargs and self.args.kwargs.length
        has_kwargs = has_kwarg_items or has_kwarg_formals

        if self.args.starargs or has_kwargs:
            obj = isinstance(self, AST_New) ? object : (self.expression.expression ? self.expression.expression : new AST_This())
            if isinstance(self, AST_New):
                # class constructor
                # we need to declare the class a bit differently with *args and **kwargs
                call_format()
                output.semicolon()
                output.newline()
                output.indent()
                if has_kwargs:
                    # **kwargs requires currying
                    output.print('kwargs')
                    output.with_parens(def():
                        object.print(output)
                        output.print('.__init__')
                    )
                else:
                    # *args only requires that we call apply on __init__ rather than the object itself
                    object.print(output)
                    output.print('.__init__')
            elif has_kwargs:
                # regular **kwargs call
                output.print('kwargs')
                output.with_parens(def(): call_format();)
            else:
                # *args, the format of the prefix doesn't change
                call_format()
        else:
            # regular call without *args or **kwargs
            call_format()

        # helper function for generating/dumping **kwargs argument
        output_kwargs = def():
            # items represented as **kw
            if has_kwarg_items:
                self.args.kwarg_items.forEach(def(kwname, i):
                    if i > 0:
                        output.print(',')
                        output.space()
                    kwname.print(output)
                )
                if has_kwarg_formals:
                    output.print(',')
                    output.space()

            # implicit kwargs from positional arguments
            if has_kwarg_formals:
                output.print('{')
                self.args.kwargs.forEach(def(pair, i):
                    if i: output.comma()
                    pair[0].print(output)
                    output.print(':')
                    output.space()
                    pair[1].print(output)
                )
                output.print('}')

        # *args logic requires unique compilation via apply() method
        # **kwargs always needs to be the last argument
        if self.args.starargs:
            # *args
            output.print(".apply")
            output.with_parens(def():
                obj.print(output)
                output.comma()

                if self.args.length > 1:
                    # start with basic arguments
                    output.with_square(def():
                        self.args[:-1].forEach(def(expr, i):
                            if i:
                                output.comma()
                            expr.print(output)
                        )
                    )
                else:
                    # no basic args, just start with *args
                    self.args[0].print(output)

                # proceed to **kwargs
                if has_kwargs or self.args.length > 1:
                    output.print('.concat')
                    output.with_parens(def():
                        # add *args if we didn't yet
                        if self.args.length > 1:
                            self.args[-1].print(output)
                            if has_kwargs:
                                output.comma()
                        output_kwargs()
                    )
            )

        elif has_kwargs and (isinstance(self, AST_New) or self.expression and self.expression.expression):
            # **kwargs for class methods require .call() notation since currying loses track of the context
            output.print('.call')
            output.with_parens(def():
                obj.print(output)
                for arg in self.args:
                    output.comma()
                    arg.print(output)
                output.comma()
                output_kwargs()
            )
        else:
            # regular function call
            output.with_parens(def():
                self.args.forEach(def(expr, i):
                    if i:
                        output.comma()
                    expr.print(output)
                )

                # kwargs as hash
                if has_kwargs:
                    if self.args.length:
                        output.comma()
                    output_kwargs()
            )
    )
    DEFPRINT(AST_New, def(self, output):
        output.print("new")
        output.space()
        AST_BaseCall.prototype._codegen(self, output)
    )
    AST_Seq.DEFMETHOD("_do_print", def(output):
        self = this
        p = output.parent()
        print_seq = def():
            self.car.print(output)
            if self.cdr:
                output.comma()
                if output.should_break():
                    output.newline()
                    output.indent()
                self.cdr.print(output)

        # this will effectively convert tuples to arrays
        if isinstance(p, AST_Binary)
        or isinstance(p, AST_Return)
        or isinstance(p, AST_Array)
        or isinstance(p, AST_BaseCall)
        or isinstance(p, AST_SimpleStatement):
            output.with_square(print_seq)
        else:
            print_seq()
    )
    DEFPRINT(AST_Seq, def(self, output):
        self._do_print(output)
    )
    DEFPRINT(AST_Dot, def(self, output):
        expr = self.expression
        expr.print(output)
        if isinstance(expr, AST_Number) and expr.getValue() >= 0:
            if not /[xa-f.]/i.test(output.last()):
                output.print(".")
        output.print(".")
        # the name after dot would be mapped about here.
        output.add_mapping(self.end)
        output.print_name(self.property)
    )
    DEFPRINT(AST_Sub, def(self, output):
        self.expression.print(output)
        output.print("[")
        # parse negative constants into len-constant
        if isinstance(self.property, AST_Unary) and self.property.operator == "-"
        and isinstance(self.property.expression, AST_Number):
            # TODO: this might parse incorrectly if expression is a
            # function call that might not return the same result
            # when called repeatedly. We might eventually want to
            # save the return to a temporary variable and use that
            # instead if expression is a function. Or we could just
            # throw an error if negative indices are used with a
            # type that's not AST_SymbolVar
            self.expression.print(output)
            output.print(".length")

        self.property.print(output)
        output.print("]")
    )
    DEFPRINT(AST_Splice, def(self, output):
        # splice assignment via pythonic array[start:end]
        output.print('[].splice.apply')
        output.with_parens(def():
            self.expression.print(output)
            output.comma()
            output.with_square(def():
                self.property.print(output)
                output.comma()
                self.property2.print(output)
                output.print('-')
                self.property.print(output)
            )
            output.print('.concat')
            output.with_parens(def():
                self.assignment.print(output)
            )
        )
    )
    DEFPRINT(AST_UnaryPrefix, def(self, output):
        op = self.operator
        output.print(op)
        if /^[a-z]/i.test(op):
            output.space()
        self.expression.print(output)
    )
    DEFPRINT(AST_UnaryPostfix, def(self, output):
        self.expression.print(output)
        output.print(self.operator)
    )
    DEFPRINT(AST_Binary, def(self, output):
        comparators = {
            "<": True,
            ">": True,
            "<=": True,
            ">=": True,
            "==": True,
            "!=": True
        }
        function_ops = {
            "in": "ՐՏ_in",
            "**": "Math.pow",
            "//": "Math.floor"
        }

        if self.operator in function_ops:
            output.print(function_ops[self.operator])
            output.with_parens(def():
                self.left.print(output)
                if self.operator == "//":
                    output.space()
                    output.print('/')
                    output.space()
                else:
                    output.comma()
                self.right.print(output)
            )
        elif comparators[self.operator] and isinstance(self.left, AST_Binary) and comparators[self.left.operator]:
            if isinstance(self.left.right, AST_Symbol):
                # left side compares against a regular variable,
                # no caching needed
                self.left.print(output)
                leftvar = self.left.right.name
            else:
                # some logic is being performed, let's cache it
                self.left.left.print(output)
                output.space()
                output.print(self.left.operator)
                output.space()
                output.with_parens(def():
                    nonlocal leftvar
                    output.assign("ՐՏ_Temp")
                    self.left.right.print(output)
                    leftvar = "ՐՏ_Temp"
                )

            output.space()
            output.print("&&")
            output.space()
            output.print(leftvar)
            output.space()
            output.print(self.operator)
            output.space()
            self.right.print(output)
        else:
            self.left.print(output)
            output.space()
            output.print(self.operator)
            output.space()
            self.right.print(output)
    )
    DEFPRINT(AST_Assign, def(self, output):
        if self.operator == '//=':
            output.assign(self.left)
            output.print('Math.floor')
            output.with_parens(def():
                self.left.print(output)
                output.space()
                output.print('/')
                output.space()
                self.right.print(output)
            )
            return
        if isinstance(self.left, AST_Array):
            output.print("ՐՏ_Unpack")
        else:
            self.left.print(output)
        output.space()
        output.print(self.operator)
        output.space()
        if isinstance(self.right, AST_New):
            # FIXME: a hack, see declaration for full explanation
            CREATION.push(self.left)
        self.right.print(output)
        if isinstance(self.left, AST_Array):
            output.semicolon()
            output.newline()
            unpack_tuple(self.left, output, True)
    )
    DEFPRINT(AST_Conditional, def(self, output):
        self.condition.print(output)
        output.space()
        output.print("?")
        output.space()
        self.consequent.print(output)
        output.space()
        output.colon()
        self.alternative.print(output)
    )

    # -----[ literals ]-----
    DEFPRINT(AST_Array, def(self, output):
        output.with_square(def():
            a = self.elements
            len_ = a.length
            if len_ > 0:
                output.space()
            a.forEach(def(exp, i):
                if i:
                    output.comma()
                exp.print(output)
            )
            if len_ > 0:
                output.space()
        )
    )
    DEFPRINT(AST_Object, def(self, output):
        if self.properties.length > 0:
            output.with_block(def():
                self.properties.forEach(def(prop, i):
                    if i:
                        output.print(",")
                        output.newline()
                    output.indent()
                    prop.print(output)
                )
                output.newline()
            )
        else:
            output.print("{}")
    )
    DEFPRINT(AST_ObjectKeyVal, def(self, output):
        key = self.key
        #        if (output.option("quote_keys")) {
        if self.quoted:
            output.print_string(key + "")
        elif (typeof key == "number" or not output.option("beautify") and +key + "" == key) and parseFloat(key) >= 0:
            output.print(make_num(key))
        elif not is_identifier(key):
            output.print_string(key)
        else:
            output.print_name(key)
        output.colon()
        self.value.print(output)
    )
    DEFPRINT(AST_ObjectSetter, def(self, output):
        output.print("set")
        self.value._do_print(output, True)
    )
    DEFPRINT(AST_ObjectGetter, def(self, output):
        output.print("get")
        self.value._do_print(output, True)
    )
    AST_Symbol.DEFMETHOD("definition", def():
        return this.thedef
    )
    DEFPRINT(AST_Symbol, def(self, output):
        def_ = self.definition()
        output.print_name((def_ ? def_.mangled_name or def_.name : self.name))
    )
    DEFPRINT(AST_Undefined, def(self, output):
        output.print("void 0")
    )
    DEFPRINT(AST_Hole, noop)
    DEFPRINT(AST_Infinity, def(self, output):
        output.print("1/0")
    )
    DEFPRINT(AST_NaN, def(self, output):
        output.print("0/0")
    )
    DEFPRINT(AST_This, def(self, output):
        output.print("this")
    )
    DEFPRINT(AST_Constant, def(self, output):
        output.print(self.getValue())
    )
    DEFPRINT(AST_String, def(self, output):
        output.print_string(self.getValue())
    )
    DEFPRINT(AST_Verbatim, def(self, output):
        output.print(self.getValue())
    )
    DEFPRINT(AST_Number, def(self, output):
        output.print(make_num(self.getValue()))
    )
    DEFPRINT(AST_RegExp, def(self, output):
        str_ = self.getValue().toString()
        if output.option("ascii_only"):
            str_ = output.to_ascii(str_)
        output.print(str_)
        p = output.parent()
        if isinstance(p, AST_Binary) and /^in/.test(p.operator) and p.left is self:
            output.print(" ")
    )
    def force_statement(stat, output):
        if output.option("bracketize"):
            if not stat or isinstance(stat, AST_EmptyStatement):
                output.print("{}")
            elif isinstance(stat, AST_BlockStatement):
                stat.print(output)
            else:
                output.with_block(def():
                    output.indent()
                    stat.print(output)
                    output.newline()
                )
        else:
            if not stat or isinstance(stat, AST_EmptyStatement):
                output.force_semicolon()
            else:
                stat.print(output)

    # return true if the node at the top of the stack (that means the
    # innermost node in the current output) is lexically the first in
    # a statement.
    def first_in_statement(output):
        a = output.stack()
        i = a.length
        node = a[i -= 1]
        p = a[i -= 1]
        while i > 0:
            if isinstance(p, AST_Statement) and p.body is node:
                return True
            if isinstance(p, AST_Seq) and p.car is node
            or isinstance(p, AST_BaseCall) and p.expression is node
            or isinstance(p, AST_Dot) and p.expression is node
            or isinstance(p, AST_Sub) and p.expression is node
            or isinstance(p, AST_Conditional) and p.condition is node
            or isinstance(p, AST_Binary) and p.left is node
            or isinstance(p, AST_UnaryPostfix) and p.expression is node:
                node = p
                p = a[i -= 1]
            else:
                return False

    # self should be AST_New, decide if we want to show parens or not.
    def no_constructor_parens(self, output):
        return self.args.length == 0 and not output.option("beautify")

    def best_of(a):
        best = a[0]
        len_ = best.length
        for i in range(1, a.length):
            if a[i].length < len_:
                best = a[i]
                len_ = best.length
        return best

    def make_num(num):
        str_ = num.toString(10)
        a = [ str_.replace(/^0\./, ".").replace("e+", "e") ]
        m = None

        if Math.floor(num) is num:
            if num >= 0:
                a.push("0x" + num.toString(16).toLowerCase(), # probably pointless
                "0" + num.toString(8))
            else:
                a.push("-0x" + (-num).toString(16).toLowerCase(), # probably pointless
                "-0" + (-num).toString(8))

            if m = /^(.*?)(0+)$/.exec(num):
                a.push(m[1] + "e" + m[2].length)

        elif m = /^0?\.(0+)(.*)$/.exec(num):
            a.push(m[2] + "e-" + (m[1].length + m[2].length), str_.substr(str_.indexOf(".")))

        return best_of(a)

    def make_block(stmt, output):
        if isinstance(stmt, AST_BlockStatement):
            stmt.print(output)
            return

        output.with_block(def():
            output.indent()
            stmt.print(output)
            output.newline()
        )

    # -----[ source map generators ]-----
    def DEFMAP(nodetype, generator):
        nodetype.DEFMETHOD("add_source_map", def(stream):
            generator(this, stream)
        )

    # We could easily add info for ALL nodes, but it seems to me that
    # would be quite wasteful, hence this noop in the base class.
    DEFMAP(AST_Node, noop)
    def basic_sourcemap_gen(self, output):
        output.add_mapping(self.start)

    # XXX: I'm not exactly sure if we need it for all of these nodes,
    # or if we should add even more.
    DEFMAP(AST_Directive, basic_sourcemap_gen)
    DEFMAP(AST_Debugger, basic_sourcemap_gen)
    DEFMAP(AST_Symbol, basic_sourcemap_gen)
    DEFMAP(AST_Jump, basic_sourcemap_gen)
    DEFMAP(AST_StatementWithBody, basic_sourcemap_gen)
    DEFMAP(AST_LabeledStatement, noop)
    # since the label symbol will mark it
    DEFMAP(AST_Lambda, basic_sourcemap_gen)
    DEFMAP(AST_Switch, basic_sourcemap_gen)
    DEFMAP(AST_SwitchBranch, basic_sourcemap_gen)
    DEFMAP(AST_BlockStatement, basic_sourcemap_gen)
    DEFMAP(AST_Toplevel, noop)
    DEFMAP(AST_New, basic_sourcemap_gen)
    DEFMAP(AST_Try, basic_sourcemap_gen)
    DEFMAP(AST_Catch, basic_sourcemap_gen)
    DEFMAP(AST_Finally, basic_sourcemap_gen)
    DEFMAP(AST_Definitions, basic_sourcemap_gen)
    DEFMAP(AST_Constant, basic_sourcemap_gen)
    DEFMAP(AST_ObjectProperty, def(self, output):
        output.add_mapping(self.start, self.key)
    )
)()
